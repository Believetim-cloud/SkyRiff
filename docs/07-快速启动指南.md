# SkyRiff 快速启动指南 v1.0

> **适合人群**：项目负责人、技术负责人、程序小白  
> **目标**：10分钟内启动第一个接口，验证供应商对接

---

## 一、启动前检查清单

### 1.1 必备条件
- [ ] Python 3.10+ 已安装（执行 `python --version` 确认）
- [ ] pip 已安装（执行 `pip --version` 确认）
- [ ] DyuAPI Sora2 API Key 已获取
- [ ] 文档已全部阅读完毕

### 1.2 推荐工具
- **代码编辑器**：VSCode / PyCharm
- **API测试**：Postman / Apifox
- **数据库工具**：DBeaver（可选）

---

## 二、10分钟快速启动（最小可运行版本）

### Step 1：创建项目目录

```bash
# Windows
mkdir D:\SkyRiffBackend
cd /d D:\SkyRiffBackend

# Mac/Linux
mkdir ~/SkyRiffBackend
cd ~/SkyRiffBackend
```

### Step 2：创建目录结构

```
SkyRiffBackend/
├── main.py
├── requirements.txt
└── app/
    ├── core/
    │   └── config.py
    ├── db/
    │   ├── database.py
    │   └── models.py
    ├── api/
    │   └── routes.py
    └── vendors/
        └── dyuapi_sora2.py
```

**快速创建命令**（Windows PowerShell）：
```powershell
New-Item -ItemType Directory -Path app\core, app\db, app\api, app\vendors
New-Item -ItemType File -Path main.py, requirements.txt
New-Item -ItemType File -Path app\core\config.py, app\db\database.py, app\db\models.py, app\api\routes.py, app\vendors\dyuapi_sora2.py
```

### Step 3：安装依赖

创建 `requirements.txt`：
```
fastapi==0.104.1
uvicorn==0.24.0
httpx==0.25.1
pydantic==2.5.0
sqlalchemy==2.0.23
pydantic-settings==2.1.0
```

安装：
```bash
pip install -r requirements.txt
```

### Step 4：配置文件

**app/core/config.py**
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # 供应商配置
    DYUAPI_BASE_URL: str = "https://api.dyuapi.com"
    DYUAPI_API_KEY: str = "YOUR_API_KEY_HERE"  # ⚠️ 替换为真实Key
    
    # 数据库配置
    DATABASE_URL: str = "sqlite:///./skyriff.db"
    
    # JWT配置（后续使用）
    SECRET_KEY: str = "your-secret-key-change-in-production"
    
    class Config:
        env_file = ".env"

settings = Settings()
```

**创建 .env 文件**（不要提交到Git）：
```
DYUAPI_API_KEY=sk-xxx  # 你的真实Key
SECRET_KEY=your-secret-key
```

### Step 5：数据库初始化

**app/db/database.py**
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from app.core.config import settings

engine = create_engine(
    settings.DATABASE_URL, 
    connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

**app/db/models.py**（最小版本）
```python
import time
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey, Text
from sqlalchemy.orm import relationship
from app.db.database import Base

def now_ts() -> int:
    return int(time.time())

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    phone = Column(String(20), unique=True, index=True)
    nickname = Column(String(50))
    credits = Column(Integer, default=0)
    created_at = Column(Integer, default=now_ts)

class Task(Base):
    __tablename__ = "tasks"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True)
    vendor_id = Column(String(100), index=True)
    status = Column(String(20), default="QUEUED")
    progress = Column(Integer, default=0)
    duration_sec = Column(Integer, default=10)
    ratio = Column(String(10), default="9:16")
    prompt = Column(Text)
    cost_credits = Column(Integer, default=10)
    created_at = Column(Integer, default=now_ts)
    
    asset = relationship("VideoAsset", back_populates="task", uselist=False)
    user = relationship("User")

class VideoAsset(Base):
    __tablename__ = "video_assets"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True)
    task_id = Column(Integer, ForeignKey("tasks.id"), unique=True)
    source_no_wm_url = Column(String(500))
    unlocked_no_wm = Column(Boolean, default=False)
    created_at = Column(Integer, default=now_ts)
    
    task = relationship("Task", back_populates="asset")
    user = relationship("User")
```

### Step 6：复制Adapter代码

将 **06-供应商API对接文档.md** 中第十章的完整代码复制到：
`app/vendors/dyuapi_sora2.py`

### Step 7：创建API路由

**app/api/routes.py**（最小测试版）
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel
from app.db.database import get_db
from app.db.models import User, Task, VideoAsset
from app.vendors.dyuapi_sora2 import DyuSora2Adapter
from app.core.config import settings

router = APIRouter()

# 初始化Adapter
adapter = DyuSora2Adapter(
    api_key=settings.DYUAPI_API_KEY,
    base_url=settings.DYUAPI_BASE_URL
)

# ==================== 测试接口 ====================

@router.get("/health")
def health_check():
    """健康检查"""
    return {"status": "ok", "message": "SkyRiff Backend is running"}

# ==================== 创建任务 ====================

class CreateTaskRequest(BaseModel):
    user_id: int
    prompt: str
    duration_sec: int = 10
    ratio: str = "9:16"

@router.post("/tasks/create")
async def create_task(req: CreateTaskRequest, db: Session = Depends(get_db)):
    """
    创建视频生成任务（文生）
    
    测试：
    {
      "user_id": 1,
      "prompt": "一只可爱的猫咪在草地上奔跑",
      "duration_sec": 10,
      "ratio": "9:16"
    }
    """
    # 1. 检查用户
    user = db.query(User).filter(User.id == req.user_id).first()
    if not user:
        raise HTTPException(404, "用户不存在")
    
    # 2. 检查积分
    cost = req.duration_sec
    if user.credits < cost:
        raise HTTPException(400, f"积分不足，需要{cost}积分，当前{user.credits}积分")
    
    # 3. 预扣积分
    user.credits -= cost
    
    # 4. 调用供应商API
    try:
        result = await adapter.create_text2video(
            prompt=req.prompt,
            duration_sec=req.duration_sec,
            ratio=req.ratio
        )
    except Exception as e:
        # 失败退款
        user.credits += cost
        db.commit()
        raise HTTPException(500, f"供应商API调用失败: {str(e)}")
    
    # 5. 创建任务记录
    task = Task(
        user_id=user.id,
        vendor_id=result.vendor_id,
        status=result.status.value,
        progress=result.progress,
        prompt=req.prompt,
        duration_sec=req.duration_sec,
        ratio=req.ratio,
        cost_credits=cost
    )
    db.add(task)
    db.commit()
    db.refresh(task)
    
    return {
        "task_id": task.id,
        "vendor_id": result.vendor_id,
        "status": task.status,
        "cost_credits": cost,
        "remaining_credits": user.credits
    }

# ==================== 查询任务 ====================

@router.get("/tasks/{task_id}")
async def get_task(task_id: int, db: Session = Depends(get_db)):
    """查询任务状态"""
    task = db.query(Task).filter(Task.id == task_id).first()
    if not task:
        raise HTTPException(404, "任务不存在")
    
    # 轮询供应商状态
    try:
        state = await adapter.get_task_state(task.vendor_id)
        
        # 更新本地状态
        task.status = state.status.value
        task.progress = state.progress
        
        # 如果成功且未创建资产
        if state.status.value == "SUCCESS" and state.video_url and not task.asset:
            asset = VideoAsset(
                user_id=task.user_id,
                task_id=task.id,
                source_no_wm_url=state.video_url
            )
            db.add(asset)
        
        # 如果失败且未退款
        if state.status.value == "FAILURE" and task.status != "FAILURE":
            user = db.query(User).filter(User.id == task.user_id).first()
            if user:
                user.credits += task.cost_credits
        
        db.commit()
        db.refresh(task)
        
    except Exception as e:
        print(f"轮询供应商失败: {e}")
    
    return {
        "task_id": task.id,
        "status": task.status,
        "progress": task.progress,
        "video_url": task.asset.source_no_wm_url if task.asset else None,
        "created_at": task.created_at
    }

# ==================== 测试用户创建 ====================

@router.post("/test/create_user")
def create_test_user(phone: str, credits: int = 100, db: Session = Depends(get_db)):
    """创建测试用户"""
    user = User(phone=phone, nickname=f"用户{phone[-4:]}", credits=credits)
    db.add(user)
    db.commit()
    db.refresh(user)
    return {"user_id": user.id, "credits": user.credits}
```

### Step 8：主入口文件

**main.py**
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api.routes import router
from app.db.database import Base, engine

# 创建数据库表
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="SkyRiff Backend",
    version="0.1.0",
    description="SkyRiff AI视频社交平台后端API"
)

# CORS配置（开发环境）
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(router, prefix="/api/v1")

@app.get("/")
def root():
    return {
        "name": "SkyRiff Backend",
        "version": "0.1.0",
        "status": "running",
        "docs": "/docs"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
```

### Step 9：启动服务

```bash
python main.py
```

或者：
```bash
uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

### Step 10：测试接口

**1. 访问API文档**
```
http://localhost:8000/docs
```

**2. 创建测试用户**
```bash
curl -X POST "http://localhost:8000/api/v1/test/create_user?phone=13800138000&credits=100"
```

**3. 创建视频任务**
```bash
curl -X POST "http://localhost:8000/api/v1/tasks/create" \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "prompt": "一只可爱的橘猫在绿色草地上奔跑",
    "duration_sec": 10,
    "ratio": "9:16"
  }'
```

**4. 查询任务状态**
```bash
curl "http://localhost:8000/api/v1/tasks/1"
```

---

## 三、验证成功标准

### ✅ 启动成功
- [ ] 服务启动无报错
- [ ] 访问 http://localhost:8000 返回JSON
- [ ] 访问 http://localhost:8000/docs 能看到Swagger文档

### ✅ 数据库成功
- [ ] 项目目录下生成 `skyriff.db` 文件
- [ ] 测试创建用户成功

### ✅ 供应商对接成功
- [ ] 创建任务返回 `task_id` 和 `vendor_id`
- [ ] 查询任务能看到状态变化（QUEUED → IN_PROGRESS → SUCCESS）
- [ ] 成功后能拿到 `video_url`

---

## 四、常见问题

### Q1: ModuleNotFoundError: No module named 'app'
**解决**：确保在项目根目录运行，或设置PYTHONPATH
```bash
# Windows
set PYTHONPATH=%CD%
python main.py

# Mac/Linux
export PYTHONPATH=$PWD
python main.py
```

### Q2: 供应商API返回401 Unauthorized
**原因**：API Key错误或未设置  
**解决**：检查 `.env` 文件中的 `DYUAPI_API_KEY`

### Q3: 任务一直QUEUED不变化
**原因**：需要轮询接口  
**解决**：持续调用 `GET /tasks/{task_id}` 查询状态

### Q4: 数据库文件在哪？
**位置**：项目根目录 `skyriff.db`  
**查看**：使用DBeaver或SQLite Browser打开

---

## 五、下一步开发

### Phase 1 完整功能清单
- [ ] 图生视频（上传图片接口）
- [ ] 项目管理（创建/重命名/删除）
- [ ] 无水印下载（扣6积分）
- [ ] 播放代理（不暴露供应商直链）
- [ ] 失败自动退款

### 参考文档
- **04-开发优先级清单.md** - 详细开发步骤
- **06-供应商API对接文档.md** - Adapter使用说明
- **03-API接口规格文档.md** - 完整接口定义

---

## 六、生产环境部署检查

### 安全配置
- [ ] 修改 `SECRET_KEY` 为随机强密码
- [ ] 不要把 `.env` 提交到Git（加入.gitignore）
- [ ] API Key 使用环境变量，不写死在代码
- [ ] 关闭 CORS `allow_origins=["*"]`，改为具体域名

### 数据库
- [ ] 从SQLite切换到PostgreSQL
- [ ] 配置数据库备份
- [ ] 设置连接池大小

### 性能
- [ ] 使用 Gunicorn + Uvicorn 部署
- [ ] 配置反向代理（Nginx）
- [ ] 启用日志记录
- [ ] 配置监控（Sentry/Prometheus）

---

**文档版本**：v1.0  
**最后更新**：2025-12-25  
**维护者**：SkyRiff技术团队
